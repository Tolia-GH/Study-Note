# [主页](../README.md)/[OPD](readme.md)/OPD Part 1

### 1.3 Система команд базовой ЭВМ 基础计算机的指令系统
Классификация команд. БЭВМ способна исполнять точно определённый набор команд. При составлении программы пользователь ограничен этими командами. Полный перечень команд базовой ЭВМ приведён в таблице В.3. В зависимости от особенностей выполнения различных операций в БЭВМ команды можно разделить на четыре группы:
指令分类。计算机能够执行一组特定的指令。在编写程序时，用户受到这些指令的限制。基础计算机的完整指令集列于表B.3中。根据在基础计算机中执行不同操作的特性，指令可以分为四类：
- безадресные команды;
  无地址指令;
- команды ввода-вывода;
  输入输出指令;
- адресные команды;
  地址指令;
- команды ветвления.
  分支指令。

Выбор одного из типов команды осуществляется МПУ при помощи анализа старших четырех бит кода команды (биты с 12 по 15), которые называются кодом операции (КОП, Opcode - Operation code). Разработчики БЭВМ выбрали шесть форматов 16-битовых (однословых) команд с 4-битовым кодом операции (рис. В.2).
通过分析指令代码的高四位（位12到15），微处理器选择一种指令类型，这些高四位称为操作码（КОП, Opcode - Operation code）。基础计算机的设计者选择了六种16位（单词）指令格式，每种指令都有4位操作码（见图B.2）。
![](/OPD/Picture/1.3.B.2.png)

**Безадресные команды** выполняют различные действия без ссылок на ячейку памяти. Например, команда `CLA` предписывает ЭВМ очистить аккумулятор (записать в AC код нуля). Это команда обработки операнда, расположенного в конкретном месте, "известном" машине. Другой пример безадресной команды - команда `HLT`. Формат команды состоит из значения 0 в КОП и расширения кода операции (биты 0-11), которое задает необходимую операцию без использования явного указания ячейки памяти. Следует отметить, что безадресные операции могут использовать ячейки памяти неявно, например, команды `POP` или `RET`.
**无地址指令** 执行各种操作而不引用内存单元。例如，指令 `CLA` 指示计算机清除累加器（将零代码写入AC）。这是一个处理操作数的指令，位于机器“已知”的特定位置。另一个无地址指令的例子是 `HLT` 指令。指令格式由操作代码中的0值和操作码扩展部分（位0-11）组成，它定义了无需明确指定内存单元的操作。值得注意的是，无地址操作可以隐式使用内存单元，例如 `POP` 或 `RET` 指令。

**Команды ввода-вывода** управляют обменом данными между процессором и внешними устройствами ЭВМ. Эти команды будут подробно рассмотрены в части 2.
**输入/输出指令** 控制处理器与计算机外部设备之间的数据交换。这些指令将在第2部分详细讨论。
![](/OPD/Picture/1.3.B.3.png)

**Примечания**:
**注释**：
1. Значения в столбцах признаков результатов показывают, как изменится соответствующий признак в результате выполнения операции. «–» - команда не влияет на признак, «0» - признак сбросится, «*» - значение признака установится по результату операции.
结果标志列中的值表示执行操作后相应标志将如何变化。“–” 表示指令不影响标志，“0” 表示标志将被重置，“*” 表示根据操作结果设置标志值。

**Адресные команды** предписывают машине производить действия с ячейкой памяти, адрес которой определяется исходя из адресной части команды, состоящей из 12 бит (биты 0..11). КОП (биты 12..15) принимает значения от 0x2 до 0xE и задает операцию.
**地址命令**指示机器对内存单元执行操作，该内存单元的地址由命令的地址部分确定，地址部分由12位组成（位0..11）。COP（位12..15）取值从0x2到0xE并定义操作。

**Команды ветвления** позволяют продолжить вычислительный процесс с другого адреса программы в зависимости от состояния признаков результата NZVC.
**分支命令**允许根据NZVC结果标志的状态从另一个程序地址继续计算过程。

**Режимы адресации в адресных командах**. Для адресных команд предусмотрено два различных формата:
**地址命令中的寻址模式**。 地址命令提供了两种不同的格式：

1. **С прямой абсолютной адресацией** (рис. В.2.б) — в бите 11 у этих команд всегда 0, а в адресной части (битах с 0 по 10) записано абсолютное значение адреса операнда (т.е. номер ячейки в адресном пространстве) в памяти. При выполнении операции команда непосредственно обращается по заданному адресу выбирая или записывая операнд.
**使用直接绝对寻址**（图B.2.b）——在这些命令中，位11总是0，并且在地址部分（位0到10）中记录了操作数地址的绝对值（即地址空间中的单元编号）在内存中。执行操作时，命令直接访问指定地址以读取或写入操作数。

1. **С относительной адресацией** (рис. В.2.г)— 11-й бит содержит 1, а биты 8-10 режим адресации. В биты 0-7 записано смещение, которое используется для вычисления адреса операнда в памяти с помощью прибавления смещения к
значению 1Р. Смещение может быть и положительным и отрицательным, позволяя адресовать 127 ячеек до и 128 ячеек после текущей команды в памяти. Подчеркнем, что смещение 0 будет указывать на следующую за командой ячейку. Это происходит потому, что к моменту вычисления адреса операнда, счетчик команд уже увеличен на 1 в результате исполнения команды. Режимы адресации могут быть:
**使用相对寻址**（图B.2.g）——第11位包含1，第8-10位表示寻址模式。第0-7位存储偏移量，用于通过将偏移量加到IP的值来计算内存中操作数的地址。偏移量可以是正数或负数，允许在内存中对当前指令前127个单元和后128个单元进行寻址。值得强调的是，偏移量为0将指向紧随指令之后的单元。这是因为在计算操作数地址时，指令计数器已经因为执行指令而增加了1。寻址模式可以是：

   - Прямая относительная (код 0xE) или еще ее называют «прямая со смещением относительно IP». Адрес операнда получается сложением закодированного в команде смещения со счетчиком команд.
     直接相对寻址（代码 0xE），也称为“相对 IP 的直接寻址”。操作数的地址通过将命令中的编码偏移量与指令计数器相加获得。
   - Косвенная относительная (0x8). Косвенная адресация подразумевает, что в ячейке памяти, которая вычисляется из адресной части команды через сложение смещения со счетчиком команд, хранится адрес операнда. В результате после вычисления ячейки, где хранится адрес, ее значение снова используется в качестве адреса, вычисляя расположение операнда в памяти.
     间接相对寻址（0x8）。间接寻址意味着在通过将偏移量与指令计数器相加来计算的命令地址部分的内存单元中，存储着操作数的地址。结果是，在计算存储地址的内存单元后，其值再次用作地址，用于计算操作数在内存中的位置。

   - Косвенная автоинкрементная (0xA). Эта адресация аналогична случаю косвенной адресации, однако `после` загрузки операнда из памяти, значение адреса в ячейке памяти увеличивается на 1. Режим обычно удобно использовать для обработки элементов массива, заданных начальным адресом и длиной в порядке возрастания порядкового номера элементов.
     间接自动增量寻址（0xA）。这种寻址类似于间接寻址，但在从内存加载操作数之后，内存单元中的地址值增加 1。通常使用这种模式来处理由初始地址和长度按元素顺序递增的数组元素。

   - Косвенная автодекрементная (0xB). Эта адресация аналогична случаю косвенной адресации, однако `перед` загрузкой операнда из памяти, значение адреса в ячейке памяти уменьшается на 1. Режим обычно удобно использовать для обработки элементов массива, заданных начальным адресом и длиной в порядке убывания порядкового номера элементов.
     间接自动减量寻址（0xB）。这种寻址类似于间接寻址，但在从内存加载操作数之前，内存单元中的地址值减少 1。通常使用这种模式来处理由初始地址和长度按元素顺序递减的数组元素。
  
   - Со смещением относительно SP (0xC). Адрес операнда получается сложением закодированного в команде смещения с указателем стека. Режим позволяет адресовать параметры с заданным номером, которые находятся в стеке.
     相对 SP 的偏移寻址（0xC）。操作数的地址通过将命令中的编码偏移量与堆栈指针相加获得。该模式允许寻址堆栈中具有指定编号的参数。

   - С непосредственной (прямой) загрузкой операнда (0xF) в аккумулятор (рис. В.2д). Для такого формата биты 8-11 установлены в единицы. Команда с режимом адресации «прямая загрузка» по факту не является адресной, а только использует формат адресной команды. Она берет число в битах 0-7 команды в качестве операнда и рассматривает его как знаковое, расширяя знак байта (бит 7) в биты 8-15 старшего байта. 
   Сводная информация о режимах адресации приведена в табл.В.10.
     直接加载操作数到累加器（代码 0xF）（见图 В.2д）。对于这种格式，比特 8-11 被设置为1。采用“直接加载”寻址模式的命令实际上不是地址模式，而只是使用地址命令的格式。它将命令中比特 0-7 的数字作为操作数，并将其视为符号数，将符号位（比特 7）扩展到高字节的比特 8-15。
     寻址模式的汇总信息在表 В.10 中给出。

### 1.4 Представление данных в БЭВМ 基础计算机中数据的表示
Архитектура фон-Неймана предполагает использование общей памяти для данных и команд. При этом в ячейках памяти просто хранятся числовые значения, а их интерпретация ложится на разработчика программ для ЭВМ. Интерпретация значения, содержащегося в ячейке памяти называется областью преставления
данных (ОП). Не зная, как организованна программа в памяти, как она использует значения разрядов слова той или иной ячейки, очень сложно интерпретировать ее
содержимое. Например, значение ячейки ${3021}_{16}$ может быть кодом команды `OR 0x21`, беззнаковым числом ${12321}_{10}$ , двумя символами ASCII «0!», набором логических переменных, чем нибудь другим или не быть ничем, представляя собой случайный набор бит в памяти после включения ЭВМ.
冯·诺依曼架构假设使用统一的内存来存储数据和指令。在这种情况下，内存单元中仅存储数值，而它们的解释则由计算机程序开发人员负责。对内存单元中包含的值的解释称为数据表示域（ОП）。如果不知道程序在内存中的组织方式，以及它如何使用某个内存单元中某个字的位值，就很难解释其内容。例如，内存单元的值 ${3021}_{16}$ 可能是指令代码OR 0x21，无符号数 ${12321}_{10}$ ，两个ASCII字符“0!”，一组逻辑变量，或者其他任何东西，也可能什么都不是，只是计算机开机后内存中的随机位集合。

Количество использованных бит памяти, совместно с областью
представления, задает область допустимых значений (ОДЗ) для данных, которые мы, как разработчики программы, размещаем в оперативной памяти. ОДЗ
применяется в вычислительной технике по аналогии с алгеброй.
使用的内存位数与表示域（ОП）共同确定了我们作为程序开发人员在内存中存放的数据的可允许值域（ОДЗ）。在计算机科学中，ОДЗ的概念类似于代数学中的值域。

В любой ЭВМ в ячейке памяти можно хранить данные различных типов ——
числа с фиксированной и плавающей точкой, логические переменные, символы истроки символов, и т.д. В БЭВМ ОП и ОДЗ связаны с размером машинного слова,которое, как мы знаем, составляет 16 двоичных разрядов.
在任何计算机中，内存单元都可以存储各种类型的数据——定点和浮点数、逻辑变量、字符和字符串等。在小型计算机中，表示域（ОП）和允许值域（ОДЗ）与机器字的大小相关联，我们知道机器字的大小是16个二进制位。

### 1.4.1 Представление чисел в БЭВМ 基础计算机中数字的表示
16-ти разрядное машинное слово БЭВМ может быть интерпретировано как
знаковое или беззнаковое.
16位小型计算机的机器字可以解释为有符号或无符号数。

Если мы зафиксируем двоичную точку числа непосредственно за 0-вым
разрядом и используем все 16 разрядов машинного слова для хранения значения числа, задав тем область представления, то беззнаковое представление можно
использовать для представления нуля и натуральных чисел, не превышающих
$65535$. Подобные числа (так же как и рассмотренные ниже двоичные числа со знаком) называются числами с фиксированной точкой, разделяющей целую и дробную части числа. При размещении таких чисел в одном 16-разрядном слове они могут изменяться от ${(0000 0000 0000 0000)}_{2}$ = ${(0000)}_{16}$ = $0$ до ${(1111 1111 1111 1111)}_{2}$ =
${(FFFF)}_{16}$ = ${2}^{16}$ - $1$ = $65535$. Такая запись называется прямым колом числа.
如果我们将数值的二进制小数点固定在第0位之后，并使用所有16位机器字来存储数值，从而定义表示域，则可以使用无符号表示来表示不超过65535的零和自然数。此类数（以及下面讨论的带符号的二进制数）称为定点数，定点数的整数部分和小数部分由固定的小数点分隔。当这些数存储在一个16位字中时，其范围可以从 ${(0000 0000 0000 0000)}{2}$ = ${(0000)}{16}$ = $0$ 到 ${(1111 1111 1111 1111)}{2}$ = ${(FFFF)}{16}$ = $2^{16} - 1$ = $65535$。这种表示法称为数值的直接编码。

Целочисленное знаковое пресставление числа используются тогда, когда необходимо различать положительные и отрицательные числа. В современных ЭВМ для представления целых чисел со знаком используется дополнительный код, В котором старший бит формата определяет знак числа: 0 - для положительных чисел и 1 - для отрицательных чисел. При этом дополнительный код положительного числа совпадает с его прямым кодом. А для представления отрицательного числа в дополнительном коде производится инвертирование прямого кода модуля числа (получение обратного кода числа) и добавление к результату единицы. Такая же операция используется при изменении знака числа, представленного вдополнительном коде.Дополнительный код определен для любой системы счисления, включая, например,десятичную.
有符号整数表示用于区分正数和负数。在现代计算机中，有符号整数的表示采用补码形式，其中最高位表示数的符号：0 表示正数，1 表示负数。正数的补码与其原码相同。而对于负数的表示，先对其绝对值的原码进行逐位取反（得到反码），然后对结果加1。相同的操作也用于改变以补码表示的数的符号。补码可以用于任何进位制系统，包括十进制系统。

Итак, например, для представления числа  ${-709}_{10}$  в дополнительном коде потребуется:
以下是将  ${-709}_{10}$  表示为补码形式的步骤：

1. Записать прямой код модуля заданного числа:
   直接写出给定数字的模的代码：
```
0 000 0010 1100 0101  Модуль числа 709
```

2. Найти поразрядное дополнение для каждой цифры числа(для двоичной системы счисления это аналогично его инверсии, или замене всех 0 на 1, а всех 1 - на 0):
   找出数字每个位的比特补码（对于二进制数系统，这类似于反转，或将所有 0 替换为 1，将所有 1 替换为 0）：
```
1 111 1101 0011 1010  Инверсия
```

3. Прибавить единицу к полученному результату:
   在所得结果上加 1：
   
```  
1 111 1101 0011 1010
+                  1
—————————————————————
1 111 1101 0011 1011  Число -709 в дополнительном коде
```         

Так как перенос из старшего разряда выходит за пределы разрядной сетки, то по правилам операций со знаковыми числами в дополнительном коде, он не учитывается. Оставшаяся же 16-разрядная сумма равна нулю, что подтверждает правильность преобразования.
由于进位从最高位溢出，按照补码形式有符号数的操作规则，它不会被考虑。剩下的16位和为零，这验证了转换的正确性。

Использование дополнительного кода упрощает конструкцию ЭВМ, так как
при сложении двух таких чисел, имеющих разные знаки, не требуется переходить к операциям вычитания меньшего (по модулю) числа из большего и присвоения результату знака большего числа. Кроме того, одной и той же схемой сумматора можно воспользоваться для выполнения операций над знаковым и беззнаковым представлением числа. Признаком выхода за границы разрядной сетки для беззнакового представления числа является перенос в старший разряд (бит С -
Саггу). Признаком переполнения разрядной сетки для знакового представления является бит переполнения (OVerflow). Рассмотрим возникновение этих ситуаций на примере представления чисел в четырехразрядной сетке (рис. В.4).
使用补码简化了计算机的设计，因为在对两个具有不同符号的补码数进行加法时，不需要转到减法操作，即从较大的数中减去较小的数（按绝对值计算）并赋予结果较大的数的符号。此外，同一加法器电路可以用于有符号和无符号数的运算。对于无符号数，超出位数范围的标志是进位到最高位（Carry-out）。对于有符号数，超出位数范围的标志是溢出位（Overflow）。我们可以通过四位数的表示来考察这些情况（见图V.4）。
![](/OPD/Picture/1.4.B.4.png)

Процессор определяет переполнение по следующему правилу: если поразрядные переносы в знаковый и из знакового разряда одновременно отсутствуют или присутствуют - значит переполнения нет, если присутствует только в одном - значит переполнение знаковой разрядной сетки есть. Для приведенного примера знаковый разряд имеет номер 3, для слова БЭВМ — номер 15.
处理器通过以下规则来确定是否发生了溢出：如果符号位和从符号位传出的进位同时不存在或同时存在，则表示没有溢出；如果只有一个存在，则表示发生了有符号数的溢出。在给出的例子中，符号位的编号是3，对于16位的机器字，则是15。

Разрядная сетка слова, с которой БЭВМ выполняет операции, состоит из 16 разрядов. Если необходимо более высокая разрядность числа, то при помощи команды учета переноса при сложении (`АОС`) возможны операции с 32-х разрядными числами и числами более высокой разрядности. В зависимости от необходимого представления числа программист должен учитывать максимальное и минимальное значение для используемых чисел.
机器字的位数，现代计算机执行操作时为16位。如果需要更高的位数，可以通过使用进位处理指令（`AOC`）来进行32位及更高位数的数值操作。根据所需的数值表示，程序员必须考虑所使用数值的最大值和最小值。

БЭВМ не умеет на уровне машинных команд работать с числами с плавающей точкой. Представление логической и символьной информации не отличаются от современных ЭВМ и выходят за рамки данных методических указаний.
小型计算机在机器指令级别不支持浮点数操作。逻辑信息和字符信息的表示与现代计算机类似，超出了本方法指导的范围。

### 1.5 Операции с памятью и арифметические операции 内存运算和算术运算








